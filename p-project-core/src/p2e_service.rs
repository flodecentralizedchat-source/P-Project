//! Play-to-Earn (P2E) systems: cooperation, puzzles, missions.
use chrono::{NaiveDateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

/// Difficulty tiers for peace puzzles.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum PuzzleDifficulty {
    Easy,
    Medium,
    Hard,
}

/// Rewards mapped by puzzle difficulty.
#[derive(Debug, Clone)]
pub struct PuzzleRewardSchedule {
    pub easy: f64,
    pub medium: f64,
    pub hard: f64,
}

impl PuzzleRewardSchedule {
    fn reward(&self, difficulty: PuzzleDifficulty) -> f64 {
        match difficulty {
            PuzzleDifficulty::Easy => self.easy,
            PuzzleDifficulty::Medium => self.medium,
            PuzzleDifficulty::Hard => self.hard,
        }
    }
}

/// Focus type for community missions.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum MissionFocus {
    CommunityBuilding,
    Education,
    Environment,
}

/// Configuration for P2E incentives.
#[derive(Debug, Clone)]
pub struct P2EConfig {
    pub cooperative_reward_per_member: f64,
    pub cooperative_bonus_per_extra_member: f64,
    pub puzzle_rewards: PuzzleRewardSchedule,
    pub mission_reward: f64,
}

impl Default for P2EConfig {
    fn default() -> Self {
        Self {
            cooperative_reward_per_member: 10.0,
            cooperative_bonus_per_extra_member: 2.0,
            puzzle_rewards: PuzzleRewardSchedule {
                easy: 5.0,
                medium: 10.0,
                hard: 20.0,
            },
            mission_reward: 15.0,
        }
    }
}

/// Player profile for P2E interactions.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlayerProfile {
    pub player_id: String,
    pub username: String,
    pub wallet_address: String,
    pub joined_at: NaiveDateTime,
    pub total_tokens: f64,
    pub achievements: HashSet<String>,
}

/// Record representing a cooperative teamwork task.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CooperativeTask {
    pub task_id: String,
    pub name: String,
    pub description: String,
    pub required_members: usize,
    pub participants: HashSet<String>,
    pub is_completed: bool,
    pub created_at: NaiveDateTime,
}

/// Puzzle challenge players can solve.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PuzzleChallenge {
    pub puzzle_id: String,
    pub title: String,
    pub description: String,
    pub difficulty: PuzzleDifficulty,
    pub solution: String,
    pub metadata: Option<String>,
    pub solved_by: HashSet<String>,
    pub created_at: NaiveDateTime,
}

/// Community mission content.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommunityMission {
    pub mission_id: String,
    pub name: String,
    pub description: String,
    pub focus: MissionFocus,
    pub participants: HashSet<String>,
    pub is_active: bool,
    pub created_at: NaiveDateTime,
}

/// Audit record for rewards generated by P2E features.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct P2ERewardTransaction {
    pub id: String,
    pub player_id: String,
    pub amount: f64,
    pub reason: String,
    pub context: Option<String>,
    pub timestamp: NaiveDateTime,
}

/// Main service handling Play-to-Earn actions.
pub struct P2EService {
    pub config: P2EConfig,
    pub players: HashMap<String, PlayerProfile>,
    pub cooperative_tasks: HashMap<String, CooperativeTask>,
    pub puzzles: HashMap<String, PuzzleChallenge>,
    pub missions: HashMap<String, CommunityMission>,
    pub balances: HashMap<String, f64>,
    pub ledger: Vec<P2ERewardTransaction>,
    mission_completions: HashMap<String, HashSet<String>>,
}

impl P2EService {
    pub fn new(config: P2EConfig) -> Self {
        Self {
            config,
            players: HashMap::new(),
            cooperative_tasks: HashMap::new(),
            puzzles: HashMap::new(),
            missions: HashMap::new(),
            balances: HashMap::new(),
            ledger: Vec::new(),
            mission_completions: HashMap::new(),
        }
    }

    fn now() -> NaiveDateTime {
        Utc::now().naive_utc()
    }

    fn next_id(prefix: &str) -> String {
        format!("{}_{}", prefix, uuid::Uuid::new_v4())
    }

    fn credit_player(
        &mut self,
        player_id: &str,
        amount: f64,
        reason: &str,
        context: Option<String>,
    ) {
        if amount <= 0.0 {
            return;
        }
        let balance = self.balances.entry(player_id.to_string()).or_insert(0.0);
        *balance += amount;
        if let Some(player) = self.players.get_mut(player_id) {
            player.total_tokens += amount;
        }
        self.ledger.push(P2ERewardTransaction {
            id: Self::next_id("p2e_reward"),
            player_id: player_id.to_string(),
            amount,
            reason: reason.to_string(),
            context,
            timestamp: Self::now(),
        });
    }

    fn ensure_player(&self, player_id: &str) -> Result<&PlayerProfile, String> {
        self.players
            .get(player_id)
            .ok_or_else(|| "player not found".to_string())
    }

    pub fn register_player(
        &mut self,
        username: &str,
        wallet_address: &str,
    ) -> Result<PlayerProfile, String> {
        if username.trim().is_empty() {
            return Err("username is required".to_string());
        }
        if wallet_address.trim().is_empty() {
            return Err("wallet address is required".to_string());
        }
        let player_id = Self::next_id("player");
        let profile = PlayerProfile {
            player_id: player_id.clone(),
            username: username.trim().to_string(),
            wallet_address: wallet_address.trim().to_string(),
            joined_at: Self::now(),
            total_tokens: 0.0,
            achievements: HashSet::new(),
        };
        self.players.insert(player_id.clone(), profile.clone());
        Ok(profile)
    }

    pub fn create_cooperative_task(
        &mut self,
        name: &str,
        description: &str,
        required_members: usize,
    ) -> Result<CooperativeTask, String> {
        if name.trim().is_empty() {
            return Err("task name is required".to_string());
        }
        if required_members < 2 {
            return Err("at least two members required".to_string());
        }
        let task_id = Self::next_id("coop");
        let task = CooperativeTask {
            task_id: task_id.clone(),
            name: name.trim().to_string(),
            description: description.trim().to_string(),
            required_members,
            participants: HashSet::new(),
            is_completed: false,
            created_at: Self::now(),
        };
        self.cooperative_tasks.insert(task_id.clone(), task.clone());
        Ok(task)
    }

    pub fn join_cooperative_task(&mut self, task_id: &str, player_id: &str) -> Result<(), String> {
        self.ensure_player(player_id)?;
        let task = self
            .cooperative_tasks
            .get_mut(task_id)
            .ok_or_else(|| "task not found".to_string())?;
        if task.is_completed {
            return Err("task already completed".to_string());
        }
        task.participants.insert(player_id.to_string());
        Ok(())
    }

    pub fn complete_cooperative_task(
        &mut self,
        task_id: &str,
    ) -> Result<Vec<P2ERewardTransaction>, String> {
        // First, check if task exists and is valid, and get the necessary data
        let (required_members, participants, reward_per_member, bonus_per_extra_member) = {
            let task = self
                .cooperative_tasks
                .get(task_id)
                .ok_or_else(|| "task not found".to_string())?;
            if task.is_completed {
                return Err("task already completed".to_string());
            }

            let extras = task
                .participants
                .len()
                .saturating_sub(task.required_members) as f64;
            let bonus = self.config.cooperative_bonus_per_extra_member * extras;
            let per_member = self.config.cooperative_reward_per_member + bonus;

            (
                task.required_members,
                task.participants.clone(),
                self.config.cooperative_reward_per_member,
                self.config.cooperative_bonus_per_extra_member,
            )
        };

        // Check if there are enough participants
        if participants.len() < required_members {
            return Err("not enough participants".to_string());
        }

        // Mark task as completed
        let task = self.cooperative_tasks.get_mut(task_id).unwrap(); // Safe because we already checked it exists
        task.is_completed = true;

        let extras = task
            .participants
            .len()
            .saturating_sub(task.required_members) as f64;
        let bonus = bonus_per_extra_member * extras;
        let per_member = reward_per_member + bonus;

        // Credit each participant
        let mut receipts = Vec::new();
        for player_id in participants.iter() {
            self.credit_player(
                player_id,
                per_member,
                "cooperative_task",
                Some(task_id.to_string()),
            );
            if let Some(tx) = self.ledger.last().cloned() {
                receipts.push(tx);
            }
        }
        Ok(receipts)
    }

    pub fn create_puzzle(
        &mut self,
        title: &str,
        description: &str,
        difficulty: PuzzleDifficulty,
        solution: &str,
        metadata: Option<String>,
    ) -> Result<PuzzleChallenge, String> {
        if title.trim().is_empty() {
            return Err("title is required".to_string());
        }
        if solution.trim().is_empty() {
            return Err("solution is required".to_string());
        }
        let puzzle_id = Self::next_id("puzzle");
        let puzzle = PuzzleChallenge {
            puzzle_id: puzzle_id.clone(),
            title: title.trim().to_string(),
            description: description.trim().to_string(),
            difficulty,
            solution: solution.trim().to_lowercase(),
            metadata,
            solved_by: HashSet::new(),
            created_at: Self::now(),
        };
        self.puzzles.insert(puzzle_id.clone(), puzzle.clone());
        Ok(puzzle)
    }

    pub fn solve_puzzle(
        &mut self,
        player_id: &str,
        puzzle_id: &str,
        answer: &str,
    ) -> Result<f64, String> {
        self.ensure_player(player_id)?;
        let puzzle = self
            .puzzles
            .get_mut(puzzle_id)
            .ok_or_else(|| "puzzle not found".to_string())?;
        if puzzle.solved_by.contains(player_id) {
            return Err("puzzle already solved by player".to_string());
        }
        if puzzle.solution != answer.trim().to_lowercase() {
            return Err("incorrect solution".to_string());
        }
        puzzle.solved_by.insert(player_id.to_string());
        let reward_amount = self.config.puzzle_rewards.reward(puzzle.difficulty);
        self.credit_player(
            player_id,
            reward_amount,
            "peace_puzzle",
            Some(puzzle_id.to_string()),
        );
        Ok(reward_amount)
    }

    pub fn create_mission(
        &mut self,
        name: &str,
        description: &str,
        focus: MissionFocus,
    ) -> Result<CommunityMission, String> {
        if name.trim().is_empty() {
            return Err("mission name required".to_string());
        }
        let mission_id = Self::next_id("mission");
        let mission = CommunityMission {
            mission_id: mission_id.clone(),
            name: name.trim().to_string(),
            description: description.trim().to_string(),
            focus,
            participants: HashSet::new(),
            is_active: true,
            created_at: Self::now(),
        };
        self.missions.insert(mission_id.clone(), mission.clone());
        Ok(mission)
    }

    pub fn complete_mission(&mut self, player_id: &str, mission_id: &str) -> Result<f64, String> {
        self.ensure_player(player_id)?;
        let mission = self
            .missions
            .get_mut(mission_id)
            .ok_or_else(|| "mission not found".to_string())?;
        if mission.focus != MissionFocus::CommunityBuilding {
            return Err("only community-building missions earn this reward".to_string());
        }
        if !mission.is_active {
            return Err("mission is not active".to_string());
        }
        let completions = self
            .mission_completions
            .entry(player_id.to_string())
            .or_insert_with(HashSet::new);
        if completions.contains(mission_id) {
            return Err("mission already completed by player".to_string());
        }
        completions.insert(mission_id.to_string());
        mission.participants.insert(player_id.to_string());
        let reward = self.config.mission_reward;
        self.credit_player(
            player_id,
            reward,
            "community_mission",
            Some(mission_id.to_string()),
        );
        Ok(reward)
    }

    pub fn get_balance(&self, player_id: &str) -> f64 {
        *self.balances.get(player_id).unwrap_or(&0.0)
    }

    pub fn list_active_missions(&self) -> Vec<&CommunityMission> {
        self.missions
            .values()
            .filter(|mission| mission.is_active)
            .collect()
    }
}
